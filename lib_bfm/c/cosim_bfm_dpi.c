//------------------------------------------------------------------------------
// Copyright (c) 2021 by Ando Ki.
// All rights reserved by Ando Ki.
//------------------------------------------------------------------------------
// cosim_bfm_dpi.c
//------------------------------------------------------------------------------
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#if defined(WIN32)  // cygwin use this
#       include <windows.h>
#       include <io.h>
#       include <process.h>
#else
#       include <unistd.h>
#endif
#include "vpi_user.h"
#include "svdpi.h"
#include "dpiheader.h" // automatically generated by HDL simulator
#include "cosim_ipc.h"
#include "cosim_bfm_packet.h"

//------------------------------------------------------------------------------
static int m_verbose = 0;
static int m_cid_max = MAX_NUM_CHAN; // see MAX_NUM_CHAN @ ipc_lib/ipc_lib.h

//------------------------------------------------------------------------------
#define dpi_printf(format, ...) printf("%s(): " format, __func__, ##__VA_ARGS__)

//------------------------------------------------------------------------------
int dpi_flush(void) { fflush(stdout); }

//------------------------------------------------------------------------------
void cosim_control(int operation) {
#if defined(ncsim)||defined(verilogXL)
     switch (operation) {
     case vpiStop  : tf_dostop();   break; // cause $stop()
     case vpiFinish: tf_dofinish(); break; // cause $finish()
     default: vpi_printf("ERROR: %d for vpi_control() is not supported yet!\n", operation);
     }
#elif defined(modelsim)||defined(questasim)
     vpi_control(operation, 0);
#endif
  if (operation==vpiFinish) {
      bfm_packet_t pkt;
      pkt.cmd_type   = COSIM_CMD_TERM_REQ;
      pkt.cmd_size   = 0;
      pkt.cmd_length = 0;
      pkt.cmd_ack    = COSIM_CMD_ACK_ERR;
      pkt.attr       = 0;
      pkt.addr       = 0;
      int len = sizeof(pkt);
      int cid;
      int dir;
      for (cid=0; cid<m_cid_max; cid++) {
          if (chn_handle(cid, &dir)!=(void*)-1L) {
             if (dir==CHAN_HOST) {
             if (chn_send(cid, len, (void*)&pkt)==len) {
                 chn_recv(cid, len, (void*)&pkt);
                 if (m_verbose>1) {
                     dpi_printf("cosim_ipc_close cid=%d.\n", cid);
                 }
             }
             }
          }
      }
  }
}

//------------------------------------------------------------------------------
// import "DPI-C" cosim_ipc_barrier=function int cosim_ipc_barrier(input int cid);
// int cosim_ipc_barrier( int cid );
//------------------------------------------------------------------------------
int cosim_ipc_barrier(const int cid) {
//printf("%s(%d)@%s\n", __func__, cid, __FILE__); fflush(stdout);
  if ((cid<0)||(cid>=m_cid_max)) {
       dpi_printf("ERROR: $cosim_ipc_barrier error: unknown channel id: %d\n", cid);
       cosim_control(vpiStop);
  }
  if (chn_handle(cid, 0)==(void*)-1L) {
       dpi_printf("ERROR: $cosim_ipc_barrier error: channel id not opened yet: %d\n", cid);
       cosim_control(vpiStop);
  }

  if (m_verbose>0) {
      dpi_printf("[proc:%ld] barrier a ipc of cid=%d\n",
                  (long)getpid(), cid); dpi_flush();
  }
  if (chn_barrier(cid)<0) {
       dpi_printf("ERROR: $cosim_ipc_barrier error: channel id: %d %s\n", cid, chn_error_msg(cid, 0));
       cosim_control(vpiStop);
  }

  if (m_verbose>0) {
      dpi_printf("[proc:%ld] barrier cid=%d\n", (long)getpid(), cid);
      dpi_flush();
  }
  return(0);
}

//------------------------------------------------------------------------------
// create and open IPC channel for HDL side for BFM (open IPC as CHAN_TARGET)
// import "DPI-C" cosim_ipc_open=function int cosim_ipc_open(input int cid);
// int cosim_ipc_open( int cid );
//------------------------------------------------------------------------------
int cosim_ipc_open(const int cid) {
//printf("%s(%d)@%s\n", __func__, cid, __FILE__); fflush(stdout);
  if ((cid<0)||(cid>=m_cid_max)) {
       dpi_printf("ERROR: $cosim_ipc_open error: unknown channel id: %d\n", cid);
       cosim_control(vpiStop);
  }
  if (chn_handle(cid, 0)!=(void*)-1L) {
       dpi_printf("ERROR: $cosim_ipc_open error: channel id in use: %d\n", cid);
       cosim_control(vpiStop);
  }

  if (m_verbose>0) {
      dpi_printf("[proc:%ld] opening a ipc of cid=%d\n",
                  (long)getpid(), cid); dpi_flush();
  }
  if (chn_create_connect(cid, CHAN_TARGET)<0) {
       dpi_printf("ERROR: $cosim_ipc_open error: channel id: %d %s\n", cid, chn_error_msg(cid, 0));
       cosim_control(vpiStop);
  }

  if (m_verbose>0) {
      dpi_printf("[proc:%ld] connected cid=%d\n", (long)getpid(), cid);
      dpi_flush();
  }
  return(0);
}

//------------------------------------------------------------------------------
// close IPC channel
// import "DPI-C" cosim_ipc_close=function int cosim_ipc_close(input int cid);
// int cosim_ipc_close( int cid );
//------------------------------------------------------------------------------
int cosim_ipc_close(const int cid) {

  if ((cid>=m_cid_max)||(chn_handle(cid, 0)==(void*)-1L)) {
       dpi_printf("ERROR: $cosim_ipc_close error: unknown channel id: %d\n", cid);
       cosim_control(vpiStop);
  }

  bfm_packet_t pkt;
  pkt.cmd_type   = COSIM_CMD_TERM_REQ;
  pkt.cmd_size   = 0;
  pkt.cmd_length = 0;
  pkt.cmd_ack    = COSIM_CMD_ACK_ERR;
  pkt.attr       = 0;
  pkt.addr       = 0;

  int len = sizeof(pkt);
  if (chn_send(cid, len, (void*)&pkt)!=len) {
      dpi_printf("ERROR: something wrong while put packet: %s\n", chn_error_msg(cid, 0));
      cosim_control(vpiStop);
  }

  if (chn_close(cid)) {
       dpi_printf("ERROR: $cosim_ipc_close error: %s\n", chn_error_msg(cid, 0));
       cosim_control(vpiStop);
  }

  if (m_verbose>0) {
      dpi_printf("cosim_ipc_closing cid=%d.\n", cid);
  }

  return(0);
}

//------------------------------------------------------------------------------
// import "DPI-C" cosim_ipc_rcv=function int cosim_ipc_rcv(
//                    input  int     cid
//                  , output int     bnum
//                  , output bit [7:0] pkt_data[]  // open-array
//                  );
// int cosim_ipc_rcv( int cid
//                  , int* bnum
//                  , const svOpenArrayHandle pkt_data);
//------------------------------------------------------------------------------
int cosim_ipc_rcv( const int   cid
                 ,       int  *bnum
                 , const svOpenArrayHandle pkt_data
                 )
{
  uint8_t pkt[1024];
  int len;
  len = chn_recv_nb(cid, 1024, (void*)&pkt);
  if (len<0) {
      dpi_printf("ERROR: something wrong while rcv packet: %s\n", chn_error_msg(cid, 0));
      cosim_control(vpiStop);
  }

  *bnum     = len;
  if (len>0) {
      if (len>svSize(pkt_data,1)) {
          dpi_printf("ERROR: data buffer size mis-match: %s\n", chn_error_msg(cid, 0));
          cosim_control(vpiStop);
      }
      int n;
      for (n=0; n<len; n++) {
           uint8_t *pt = (uint8_t*)svGetArrElemPtr(pkt_data, n);
           *pt = pkt[n];
      }
  }

  return(0);
}

//------------------------------------------------------------------------------
// import "DPI-C" cosim_ipc_snd=function int cosim_ipc_snd(
//                   input  int     cid
//                 , input  int     bnum
//                 , input  bit [7:0] pkt_data[]
//                );
// int cosim_ipc_snd( int cid
//                  , int bnum
//                  , const svOpenArrayHandle pkt_data);
//------------------------------------------------------------------------------
int cosim_ipc_snd( const int   cid
                 , const int   bnum
                 , const svOpenArrayHandle pkt_data
                )
{
  uint8_t pkt[1024];

  if (bnum==0) return 0;
  int s= bnum;
  if (s>svSize(pkt_data,1)) {
      dpi_printf("ERROR: data buffer size mis-match: %s\n", chn_error_msg(cid, 0));
      cosim_control(vpiStop);
  }
  int n;
  for (n=0; n<s; n++) {
       uint8_t *pt = (uint8_t*)svGetArrElemPtr(pkt_data, n);;
       pkt[n] = *pt;
  }

  int len = s;
  if (chn_send(cid, len, (void*)&pkt)!=len) {
      dpi_printf("ERROR: something wrong while put packet: %s\n", chn_error_msg(cid, 0));
      cosim_control(vpiStop);
  }

  return(0);
}

//------------------------------------------------------------------------------
// import "DPI-C" cosim_ipc_get=function int cosim_ipc_get(
//                    input  int     cid
//                  , output int     pkt_cmd
//                  , output int     pkt_size  // 1, 2, 4
//                  , output int     pkt_length  // burst length
//                  , output int     pkt_ack
//                  , output int     pkt_attr
//                  , output int     pkt_trans_id
//                  , output int     pkt_addr
//                  , output bit [7:0] pkt_data[]  // open-array
//                  );
// int cosim_ipc_get( int cid
//                  , int* pkt_cmd
//                  , int* pkt_size
//                  , int* pkt_length
//                  , int* pkt_ack
//                  , int* pkt_attr
//                  , int* pkt_trans_id
//                  , int* pkt_addr
//                  , const svOpenArrayHandle pkt_data);
//------------------------------------------------------------------------------
int cosim_ipc_get( const int   cid
                 ,       int  *pkt_type 
                 ,       int  *pkt_size  // 1, 2, 4
                 ,       int  *pkt_length  // burst length
                 ,       int  *pkt_ack 
                 ,       int  *pkt_attr
                 ,       int  *pkt_trans_id
                 ,       int  *pkt_addr 
                 , const svOpenArrayHandle pkt_data
                 )
{
  bfm_packet_t pkt;
  int len = sizeof(pkt);
  if (chn_recv(cid, len, (void*)&pkt)<0) {
      dpi_printf("ERROR: something wrong while get packet: %s\n", chn_error_msg(cid, 0));
      cosim_control(vpiStop);
  }
  if (m_verbose>1) {
      dpi_printf("cosim_ipc_get_Calltf: after chn_recv:\n");
      dpi_printf("\tcid        =0x%x\n", cid);
      dpi_printf("\ttype       =0x%x\n", pkt.cmd_type);
      dpi_printf("\tsize       =0x%x\n", pkt.cmd_size);
      dpi_printf("\tlength     =0x%x\n", pkt.cmd_length);
      dpi_printf("\tack        =0x%x\n", pkt.cmd_ack);
      dpi_printf("\tattr       =0x%x\n", pkt.attr);
      dpi_printf("\ttrans_id   =0x%x\n", pkt.trans_id);
      dpi_printf("\taddr       =0x%x\n", pkt.addr);
      dpi_printf("\tdata[0]    =0x%x\n", pkt.data[0]);
      dpi_printf("\tpacket size=%lu\n", sizeof(pkt));
  }

  *pkt_type     = pkt.cmd_type;
  *pkt_size     = pkt.cmd_size;
  *pkt_length   = pkt.cmd_length;
  *pkt_ack      = pkt.cmd_ack;
  *pkt_attr     = pkt.attr;
  *pkt_trans_id = pkt.trans_id;
  *pkt_addr     = pkt.addr;
  int s= pkt.cmd_size*pkt.cmd_length;
  if (s>svSize(pkt_data,1)) {
      dpi_printf("ERROR: data buffer size mis-match: %s\n", chn_error_msg(cid, 0));
      cosim_control(vpiStop);
  }
  if (pkt.cmd_type!=COSIM_CMD_RD_REQ) {
      int n;
      for (n=0; n<s; n++) {
           uint8_t *pt = (uint8_t*)svGetArrElemPtr(pkt_data, n);
           *pt = pkt.data[n];
      }
  }

  return(0);
}

//------------------------------------------------------------------------------
// import "DPI-C" cosim_ipc_put=function int cosim_ipc_put(
//                   input  int     cid
//                 , input  int     pkt_cmd
//                 , input  int     pkt_size
//                 , input  int     pkt_length
//                 , input  int     pkt_ack
//                 , input  int     pkt_attr
//                 , input  int     pkt_trans_id
//                 , input  int     pkt_addr
//                 , input  bit [7:0] pkt_data[]
//                );
// int cosim_ipc_put( int cid
//                  , int pkt_cmd
//                  , int pkt_size
//                  , int pkt_length
//                  , int pkt_ack
//                  , int pkt_attr
//                  , int pkt_trans_id
//                  , int pkt_addr
//                  , const svOpenArrayHandle pkt_data);
//------------------------------------------------------------------------------
int cosim_ipc_put( const int   cid
                 , const int   pkt_type
                 , const int   pkt_size
                 , const int   pkt_length
                 , const int   pkt_ack
                 , const int   pkt_attr
                 , const int   pkt_trans_id
                 , const int   pkt_addr
                 , const svOpenArrayHandle pkt_data
                )
{
  bfm_packet_t pkt;
  pkt.cmd_type   = pkt_type;
  pkt.cmd_size   = pkt_size;
  pkt.cmd_length = pkt_length;
  pkt.cmd_ack    = pkt_ack;
  pkt.attr       = pkt_attr;
  pkt.trans_id   = pkt_trans_id;
  pkt.addr       = pkt_addr;

  int s= pkt.cmd_size*pkt.cmd_length;
  if (s>svSize(pkt_data,1)) {
      dpi_printf("ERROR: data buffer size mis-match: %s\n", chn_error_msg(cid, 0));
      cosim_control(vpiStop);
  }
  if (pkt.cmd_type!=COSIM_CMD_WR_RSP) {
      int n;
      for (n=0; n<s; n++) {
           uint8_t *pt = (uint8_t*)svGetArrElemPtr(pkt_data, n);;
           pkt.data[n] = *pt;
      }
  }

  if (m_verbose>1) {
    dpi_printf("cosim_ipc_put_Calltf: before chn_send:\n");
    dpi_printf("\tcid        =0x%x\n", cid);
    dpi_printf("\tcmd.type   =0x%x\n", pkt.cmd_type);
    dpi_printf("\tcmd.size   =0x%x\n", pkt.cmd_size);
    dpi_printf("\tcmd.length =0x%x\n", pkt.cmd_length);
    dpi_printf("\tcmd.ack    =0x%x\n", pkt.cmd_ack);
    dpi_printf("\tattr       =0x%x\n", pkt.attr);
    dpi_printf("\ttrans_id   =0x%x\n", pkt.trans_id);
    dpi_printf("\taddr       =0x%x\n", pkt.addr);
    dpi_printf("\tdata[0]    =0x%x\n", pkt.data[0]);
    dpi_printf("\tpacket size=%lu\n", sizeof(pkt));
  }

  int len = sizeof(pkt);
  if (chn_send(cid, len, (void*)&pkt)!=len) {
      dpi_printf("ERROR: something wrong while put packet: %s\n", chn_error_msg(cid, 0));
      cosim_control(vpiStop);
  }

  return(0);
}

//------------------------------------------------------------------------------
// cosim_ipc_set_verbose(n);
//------------------------------------------------------------------------------
int cosim_ipc_set_verbose(int level) {
//printf("%s(%d)@%s\n", __func__, level, __FILE__); fflush(stdout);
  m_verbose = level;
  chn_set_verbose(level);
  return(0);
}

//------------------------------------------------------------------------------
// Revision history:
//
// 2021.07.01: Started by Ando Ki (andoki@gmail.com)
//------------------------------------------------------------------------------
